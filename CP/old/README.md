# Консоль-серверная игра "Морской бой"

## Описание проекта

Данный проект представляет собой реализацию консоль-серверной игры "Морской бой" с использованием ZeroMQ для организации общения между сервером и клиентами. Проект разработан в рамках курсового проекта по курсу "Операционные системы".

## Архитектура системы

Проект состоит из двух основных компонентов:

1. **Сервер** (`server.c`) - координирует игроков, управляет играми, обрабатывает игровую логику
2. **Клиент** (`client.c`) - предоставляет интерфейс для игроков, отправляет запросы серверу

### Компоненты проекта

- `server.c` - серверная программа
- `client.c` - клиентская программа  
- `common.h` - общие определения, структуры данных и прототипы функций
- `common.c` - реализация общих функций (работа с доской, кораблями, выстрелами)
- `CMakeLists.txt` - файл конфигурации для сборки проекта

## Технологии

- **Язык программирования**: C (стандарт C11)
- **Библиотека для межпроцессного взаимодействия**: ZeroMQ (libzmq)
- **Система сборки**: CMake

## Функциональность

### Возможности сервера

1. **Регистрация игроков**
   - Каждый игрок регистрируется на сервере с уникальным логином
   - Сервер отслеживает всех подключенных игроков

2. **Управление играми**
   - Создание новых игр с указанием имени
   - Присоединение к существующим играм по имени
   - Отслеживание статуса игр (ожидание, размещение кораблей, игра, завершена)
   - Поддержка до 100 одновременных игр

3. **Координация игроков**
   - Отправка приглашений игрокам по логину
   - Синхронизация действий игроков
   - Управление очередностью ходов

4. **Игровая логика**
   - Валидация размещения кораблей
   - Обработка выстрелов
   - Определение попаданий, промахов и потоплений
   - Определение победителя

### Возможности клиента

1. **Регистрация и подключение**
   - Регистрация на сервере с логином
   - Подключение к серверу по адресу `localhost:5555`

2. **Управление играми**
   - Создание новой игры
   - Присоединение к существующей игре по имени
   - Просмотр списка доступных игр
   - Отправка приглашений другим игрокам по логину

3. **Игровой процесс**
   - Размещение кораблей на доске (10x10)
   - Визуализация своей доски и доски противника
   - Выполнение выстрелов по координатам
   - Получение результатов выстрелов в реальном времени
   - Отображение статуса игры

## Структура данных

### Сообщения (Message)

Все взаимодействие между клиентом и сервером происходит через структуру `Message`:

```c
typedef struct {
    MessageType type;           // Тип сообщения
    char sender[MAX_PLAYER_NAME];      // Отправитель
    char recipient[MAX_PLAYER_NAME];   // Получатель
    char game_name[MAX_GAME_NAME];     // Имя игры
    char data[MAX_MESSAGE_SIZE];       // Данные сообщения
    int x, y;                          // Координаты (для выстрелов/кораблей)
    ShotResult shot_result;            // Результат выстрела
    int game_id;                       // ID игры
} Message;
```

### Типы сообщений

- `MSG_REGISTER` - регистрация игрока
- `MSG_CREATE_GAME` - создание игры
- `MSG_JOIN_GAME` - присоединение к игре
- `MSG_INVITE_PLAYER` - приглашение игрока
- `MSG_PLACE_SHIP` - размещение корабля
- `MSG_MAKE_SHOT` - выполнение выстрела
- `MSG_SHOT_RESULT` - результат выстрела
- `MSG_GAME_STATE` - состояние игры
- `MSG_GAME_OVER` - окончание игры
- `MSG_LIST_GAMES` - список игр
- `MSG_ERROR` - ошибка
- `MSG_ACK` - подтверждение

### Игра (Game)

```c
typedef struct {
    int id;                              // Уникальный ID игры
    char name[MAX_GAME_NAME];            // Имя игры
    char players[MAX_PLAYERS][MAX_PLAYER_NAME]; // Игроки
    int player_count;                    // Количество игроков
    GameStatus status;                   // Статус игры
    int current_turn;                    // Индекс игрока, чей ход
    int boards[MAX_PLAYERS][BOARD_SIZE][BOARD_SIZE]; // Доски игроков
    int shots[MAX_PLAYERS][BOARD_SIZE][BOARD_SIZE];  // История выстрелов
    int ships_remaining[MAX_PLAYERS];    // Количество оставшихся кораблей
} Game;
```

## Правила игры "Морской бой"

### Размещение кораблей

Каждый игрок размещает на своей доске 10x10 следующие корабли:
- 1 корабль размером 4 клетки
- 2 корабля размером 3 клетки
- 3 корабля размером 2 клетки
- 4 корабля размером 1 клетка

Корабли не должны:
- Пересекаться
- Касаться друг друга (даже по диагонали)
- Выходить за границы доски

### Игровой процесс

1. Игроки по очереди делают выстрелы, указывая координаты (x, y)
2. Результат выстрела:
   - **Промах** (O) - ход переходит к противнику
   - **Попадание** (X) - игрок продолжает стрелять
   - **Потопление** - корабль полностью уничтожен, игрок продолжает стрелять
3. Побеждает игрок, первым потопивший все корабли противника

## Сборка проекта

### Требования

- CMake версии 3.10 или выше
- Компилятор C с поддержкой C11
- Библиотека ZeroMQ (libzmq)
- pkg-config

### Установка зависимостей

#### Ubuntu/Debian:
```bash
sudo apt-get update
sudo apt-get install cmake build-essential libzmq3-dev pkg-config
```

#### Arch Linux:
```bash
sudo pacman -S cmake gcc zeromq pkgconf
```

### Сборка

```bash
# Создание директории для сборки
mkdir -p build
cd build

# Генерация файлов сборки
cmake ..

# Компиляция
make

# В результате будут созданы исполняемые файлы:
# - server
# - client
```

## Запуск

### Запуск сервера

```bash
./server
```

Сервер запустится на порту 5555 и будет ожидать подключений клиентов.

### Запуск клиента

```bash
./client <login>
```

Где `<login>` - уникальное имя игрока.

Пример:
```bash
./client player1
```

## Использование

### Основное меню клиента

После запуска клиента и регистрации на сервере доступны следующие опции:

1. **Create game** - создать новую игру
   - Введите имя игры
   - Дождитесь присоединения второго игрока

2. **Join game** - присоединиться к существующей игре
   - Введите имя игры
   - Начнется процесс размещения кораблей

3. **Invite player** - пригласить игрока в игру
   - Доступно только если вы уже в игре
   - Введите логин игрока для приглашения

4. **List games** - показать список доступных игр
   - Отображает все игры, ожидающие игроков

5. **Start game** - начать игру (если уже в игре)
   - Размещение кораблей
   - Начало игрового процесса

6. **Exit** - выход из программы

### Размещение кораблей

При размещении кораблей введите координаты в формате:
```
x y size horizontal
```

Где:
- `x, y` - координаты начала корабля (0-9)
- `size` - размер корабля (1-4)
- `horizontal` - направление (1 - горизонтально, 0 - вертикально)

Пример:
```
0 0 4 1    # Корабль размером 4 клетки горизонтально в позиции (0,0)
5 5 3 0    # Корабль размером 3 клетки вертикально в позиции (5,5)
```

### Игровой процесс

Во время игры:
- Отображается ваша доска (с видимыми кораблями)
- Отображается доска противника (только результаты выстрелов)
- В свой ход введите координаты выстрела: `x y`
- Результат выстрела отображается сразу

## Протокол общения

### Паттерн ZeroMQ

Используется паттерн **REQ/REP** (Request/Reply):
- Клиент использует сокет типа `ZMQ_REQ`
- Сервер использует сокет типа `ZMQ_REP`
- Каждый запрос клиента получает ответ от сервера

### Последовательность операций

1. **Регистрация**:
   ```
   Клиент -> MSG_REGISTER -> Сервер
   Сервер -> MSG_ACK/MSG_ERROR -> Клиент
   ```

2. **Создание игры**:
   ```
   Клиент -> MSG_CREATE_GAME -> Сервер
   Сервер -> MSG_ACK -> Клиент
   ```

3. **Присоединение к игре**:
   ```
   Клиент -> MSG_JOIN_GAME -> Сервер
   Сервер -> MSG_ACK -> Клиент (обоим игрокам)
   ```

4. **Размещение корабля**:
   ```
   Клиент -> MSG_PLACE_SHIP -> Сервер
   Сервер -> MSG_ACK/MSG_ERROR -> Клиент
   ```

5. **Выстрел**:
   ```
   Клиент -> MSG_MAKE_SHOT -> Сервер
   Сервер -> MSG_SHOT_RESULT -> Клиент (обоим игрокам)
   ```

## Особенности реализации

### Обработка ошибок

- Все операции проверяются на валидность
- Сервер отправляет сообщения типа `MSG_ERROR` при ошибках
- Клиент отображает сообщения об ошибках пользователю

### Синхронизация

- Сервер управляет очередностью ходов
- Статус игры обновляется централизованно на сервере
- Все изменения состояния игры синхронизируются между игроками

### Валидация

- Проверка координат на границы доски
- Проверка правильности размещения кораблей
- Проверка, что выстрел не был сделан ранее
- Проверка очереди ходов

## Ограничения

- Максимальное количество игроков на сервере: 100
- Максимальное количество одновременных игр: 100
- Размер доски: 10x10
- Количество игроков в одной игре: 2
- Максимальная длина логина: 50 символов
- Максимальная длина имени игры: 50 символов

## Возможные улучшения

1. **Многопоточность**
   - Обработка клиентов в отдельных потоках
   - Асинхронная обработка сообщений

2. **Персистентность**
   - Сохранение состояния игр в файл
   - Восстановление игр после перезапуска сервера

3. **Безопасность**
   - Аутентификация игроков
   - Шифрование сообщений

4. **Расширенная функциональность**
   - Статистика игр
   - Рейтинг игроков
   - Чат между игроками
   - Разные размеры досок

5. **Улучшение интерфейса**
   - Графический интерфейс
   - Цветной вывод в консоли
   - Автоматическое размещение кораблей

## Тестирование

### Ручное тестирование

1. Запустите сервер
2. Запустите два клиента с разными логинами
3. Создайте игру на первом клиенте
4. Присоединитесь к игре на втором клиенте
5. Разместите корабли на обеих досках
6. Проведите игру до конца

### Сценарии тестирования

- Регистрация нескольких игроков
- Создание нескольких игр
- Присоединение к несуществующей игре
- Приглашение несуществующего игрока
- Некорректное размещение кораблей
- Выстрелы за границы доски
- Повторные выстрелы в одну клетку

## Структура файлов проекта

```
CP/
├── CMakeLists.txt      # Конфигурация сборки
├── common.h            # Общие определения
├── common.c            # Реализация общих функций
├── server.c            # Серверная программа
├── client.c            # Клиентская программа
├── README.md           # Документация проекта
├── build/              # Директория сборки
│   ├── server          # Исполняемый файл сервера
│   └── client          # Исполняемый файл клиента
└── task/               # Задание курсового проекта
    └── CP_OS_v4_2025.pdf
```

## Заключение

Проект успешно реализует консоль-серверную игру "Морской бой" с использованием ZeroMQ для межпроцессного взаимодействия. Система обеспечивает:

- Надежную координацию игроков через централизованный сервер
- Корректную реализацию правил игры "Морской бой"
- Удобный консольный интерфейс для игроков
- Расширяемую архитектуру для будущих улучшений

Проект демонстрирует практическое применение знаний по операционным системам, включая:
- Межпроцессное взаимодействие
- Управление ресурсами
- Синхронизацию процессов
- Архитектуру клиент-серверных приложений

## Автор

Проект разработан в рамках курсового проекта по курсу "Операционные системы".

## Лицензия

Учебный проект.

